# Post mortem on this phase of the project

Recipe Book is supposed to be an application centered around the creation, maintenance and safekeeping of recipes. This phase of the project has been successful at letting users create recipes, ingreients, and user profiles. Where the project has only been partially successful is in the maintenance and safeguard of this data. Currently, only profiles and ingredients are saved correctly to the database, editing changes aren't reflected yet in the database, and it isn't yet possible to delete entries, although these features are close to being fully inplemented. In truth the project will likely stay in this state due to a multitude of factors, and instead this README will serve as a post mortem analysis of what went right, what went wrong, and what I can do better when I re-create this exact application using the lessons learned.

## Positives about the project

Starting with the good decisions that pushed the project along and helped development was the light use of UML diagrams to plan out and have an idea of the direction the project needed to start in. Ultimately a heavier use of UML would be important in the future, since it provides a good road map and plan of how to implement certain parts of the project. For example, if the database layer had been mapped out using UML, I would have likely had a better approach to creating database operations for each object type using a visitor pattern, instead of my current implementation of using constexpr and compile time type deduction. In the next phase of this project, I plan on using UML a lot more to better plan out the separation of layers.

Another positive decision was the strict delimitation of layers in the application code. Ui elements exclusively contain ui code. Models are (nearly, more on this later) self contained and don't have external dependencies. Factories bridge user input and model creation. The data cache layer is the bridge between the database layer and the ui. Each layer has its own responsability, and doesn't depend on any other layer. There are slight exceptions, but I consider them acceptable as a means of keeping things organized. For example, the database layer contains an implementation for SQlite3. Instead of having an implementation where each model registers its own sql table creation code, and CRUD operation code, I simply hard-coded these things in the database layer. This makes it so that any changes to the model class need to be reflected in the database implementation files. I find this acceptable, since it keeps database code separate from model code, even though it means editing code at multiple places.

## Negatives about the project

Some issues I've had working on this phase of the project have slowed down production considerably, other issues simply broke features entirely.

The single largest issue stems from a bad development decision made early on. Instead of lightly coupling different models together (having models refer to other models by id exclusively), instead I decided to tightly couple models together, storing raw pointer references. For example, the QRecipeIngredient object has a raw pointer reference to its corresponding QIngredient object. This causes issues with the way that the database layer is built, since when we read a QRecipeIngredient from the database, we don't want to be loading its QIngredient from the database if it's already in the cache, since we want to refer to the object that's in cache (and that can be modified). This problem is quite major, and culminates in the fact that QRecipeIngredient objects can't even be saved to the database correctly, since their ingredient fields are turned to nullptrs by program cleanup (and the database save function is called). It's a bad implementation decision, and in the future it would make more sense to simply store the literal values that might be relevant to composed models, and connect modification signals so that these values locally stored to a model are updated when their children are modified. To refer back to children, storing the id of the child should be sufficient so that it can be written to the database.

Another issue that I found to slow down development on this phase of the project was a lack of interfaces and generics. Of course they are a feature in the software overall, but more interfaces and generics, especially related to the implementation of the UI would have accelerated development. Having a generic 'LsitViewItem' class would have saved me from writing a full implementation for each model, and the same goes for the delegate classes.

Finally, it will be an important point in the next phase of this project to better organize files and make the project overall easier to navigate. It was a concious decision to avoid bothering structuring the project since I didn't want to think too hard about it and simply focus on getting a working prototype. For maintainability's sake it's important that in the next phase of development I focus on keeping things far more organized.

## Where to go from here

At the moment, I will likely start thinking and planning the next and hopefully final stage of development for this project. There's a lot of good that can be taken from this phase, and by implementing the good as well as improving on the bad, I should be able to make good software from these lessons.
